<html>
<head>
    <script type='text/javascript' src="Libs/Knockout/knockout-3.5.1.js"></script>
    <link rel="stylesheet" href="main.css" />
</head>

<body>
   <p>Survey Scan <textarea data-bind = "textInput: scanString" ></textarea></p>
   <button data-bind="click: copyToClipboard('https://slamma009.github.io/?scan=' + btoa(JSON.stringify(surveyResult())))">
      Copy Results
   </button>
    <table class="table">
      <thead>
         <tr>
            <td class = 'table-header'>Ore</td>
            <td class = 'table-header'>Amount (Units)</td>
            <td class = 'table-header'>Amount (m3)</td>
            <td class = 'table-header'>Average</td>
         </tr>
      </thead>
      <tbody data-bind ="foreach: surveyResult().oreGroups">
         <!-- ko foreach: ores -->
         <tr class="table-row" data-bind="css: { 'group1' : $parentContext.$index() % 2 === 0 }">
            <td data-bind="text: ore"></td>
            <td class="center-align" data-bind="number: units"></td>
            <td class="center-align" data-bind="oreAmount: amount"></td>
            <td class="center-align" data-bind="oreAmount: average"></td>
         </tr>
         <!-- /ko -->
      </tbody>
    </table>

    <p>Toal Asteroid M3: <strong data-bind="oreAmount: surveyResult().m3"></strong></p>

    <script>

       function AppViewModel() {
         ko.bindingHandlers.oreAmount = {
            update: function(element, valueAccessor, allBindingsAccessor) {
               var value = ko.utils.unwrapObservable(valueAccessor()),
                  precision = ko.utils.unwrapObservable(allBindingsAccessor().precision) || ko.bindingHandlers.oreAmount.defaultPrecision,
                  formattedValue = value.toFixed(precision);

               ko.bindingHandlers.text.update(element, function() { return formattedValue.replace(/\B(?=(\d{3})+(?!\d))/g, ",") + " m3"; });
            },
            defaultPrecision: 0  
         };

         ko.bindingHandlers.number = {
            update: function(element, valueAccessor, allBindingsAccessor) {
               var value = ko.utils.unwrapObservable(valueAccessor()),
                  precision = ko.utils.unwrapObservable(allBindingsAccessor().precision) || ko.bindingHandlers.oreAmount.defaultPrecision,
                  formattedValue = value.toFixed(precision);

               ko.bindingHandlers.text.update(element, function() { return formattedValue.replace(/\B(?=(\d{3})+(?!\d))/g, ",") });
            },
            defaultPrecision: 0  
         };

         this.getParamOrDefault = function(){
            let result = getParams(window.location.href)["survey"];
            if(!result)
               return "";
            
            return atob(result);
         }
         this.scanString = ko.observable(this.getParamOrDefault());

         this.surveyResult = ko.computed(function() {
            return parse(this.scanString());
         }, this);


         this.copyToClipboard = function(string) {

            console.log("copying string " + string)
            // Create an auxiliary hidden input
            var aux = document.createElement("input");

            // Get the text from the element passed into the input
            aux.setAttribute("value", string);

            // Append the aux input to the body
            document.body.appendChild(aux);

            // Highlight the content
            aux.select();

            // Execute the copy command
            document.execCommand("copy");

            // Remove the input from the body
            document.body.removeChild(aux);

         };
       }

      function getParams(url) {
         var params = {};
         var parser = document.createElement('a');
         parser.href = url;
         var query = parser.search.substring(1);
         var vars = query.split('&');
         for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            params[pair[0]] = decodeURIComponent(pair[1]);
         }
         return params;
      }

      function parse(str){
         let overall = 0;
         let oreGroups = [];
         let lines = str.trim().split("\n")
         for( let l of lines){
            if(!l.length) continue;
            
            let words = l.trim().split(/\s+/g);
            console.log(words.length)
            let name = words.shift()
            let group = name;
            if(words.length === 6){
               group = words.shift(); 
               name += ' '+group; 
            }

            let units = words[0];
            let m3 = words[1]

            if(!m3 || !units)
               continue;

            let m3Number = +m3.replace(/,/g,'');
            let unitsNumber = +units.replace(/,/g,'');
            
            if(isNaN(m3Number) || isNaN(unitsNumber))
               continue;

            if(!oreGroups[group]) {
               console.log(group);
               oreGroups[group] = {
                  group: group,
                  ores: []
               }
            }
            if(!oreGroups[group].ores[name])
            { 
               oreGroups[group].ores[name] = {
                  ore: name,
                  amount: 0,
                  units: 0,
                  count: 0,
                  average: 0
               }
            }



            oreGroups[group].ores[name].units += unitsNumber;
            oreGroups[group].ores[name].amount += m3Number;
            oreGroups[group].ores[name].count++;
            overall += m3Number
         }

         return {
            m3:overall,
            oreGroups:toArray(oreGroups)
         }
      }

      function toArray(oreGroups)
      {
         let castedGroup = [];
         let index = 0;
         for(let group in oreGroups) 
         {
            castedGroup[index] = {
               index: index,
               ores: []
            }
            let oreIndex = 0;
            for(let ore in oreGroups[group].ores)
            {
               castedGroup[index].ores[oreIndex] = oreGroups[group].ores[ore];
               castedGroup[index].ores[oreIndex].groupIndex = index;
               castedGroup[index].ores[oreIndex].average = oreGroups[group].ores[ore].amount / oreGroups[group].ores[ore].count;
               oreIndex += 1;
            }
            index += 1;
         }
         return castedGroup
      }

       // Activates knockout.js
       ko.applyBindings(new AppViewModel());
    </script>


</body>

</html>
